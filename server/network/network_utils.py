from dataclasses import dataclass, asdict
import logging
from typing import Optional, Tuple, List, Dict, Any
import socket
import ipaddress
from furl import furl
from concurrent.futures import ThreadPoolExecutor
from server.network.mdns.mdns_advertiser import MDNSAdvertiser
from server.crypto.crypto_state import CryptoState
from server.network.wifi_manager import WiFiManager


logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


@dataclass
class HostInfo:
    ip: str
    port: int
    mac: str

    def __iter__(self):
        yield from asdict(self).items()

    def to_dict(self):
        return asdict(self)


class NetworkUtils:
    """
    Utility class for network-related operations.
    """

    IP_KEY = 'ip'
    PORT_KEY = 'port'
    PORTS_KEY = 'ports'
    MAC_KEY = 'mac'
    HW_KEY = 'hw'
    FLAGS_KEY = 'flags'
    MASK_KEY = 'mask'
    DEVICE_KEY = 'device'
    TIMEOUT_KEY = 'timeout'
    DEFAULT_MODBUS_PORTS = "502,1502,6607,8899"
    DEFAULT_TIMEOUT = 5

    INVALID_MAC = "00:00:00:00:00:00"

    MDNS_HOSTNAME = "blixt"

    _mdns_advertiser = None

    def __init__(self):
        raise NotImplementedError("This class shouldn't be instantiated.")

    @staticmethod
    def get_ip_address() -> str:
        """Get the IP address of the device."""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip_address = s.getsockname()[0]
            s.close()
            return ip_address
        except Exception:
            return "0.0.0.0"

    @staticmethod
    def update_resolv_conf(dns_servers: List[str]) -> bool:
        """Update resolv.conf with DNS servers."""
        if not dns_servers:
            return False

        try:
            content = "# Generated by NetworkManager\n"
            content += "search localdomain\n"
            for server in dns_servers:
                content += f"nameserver {server}\n"

            with open('/etc/resolv.conf', 'w') as f:
                f.write(content)
            logger.info("Updated resolv.conf with DNS servers")
            return True
        except Exception as e:
            logger.warning("Failed to update resolv.conf: %s", str(e))
            return False

    @staticmethod
    def has_internet_access() -> bool:
        """Verify network connectivity by checking DNS resolution."""
        try:
            # Test internet connectivity by connecting to Google DNS
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(3)
                s.connect(("8.8.8.8", 53))
                logger.info("Internet access verified")
                return True
        except:
            logger.warning("No internet access")
            return False

    @staticmethod
    def extract_ip(url: str) -> Optional[str]:
        """
        Extract IP address from a URL or IP string.
        Returns the IP if valid, None if invalid.

        Args:
            url (str): URL or IP address string

        Returns:
            Optional[str]: IP address or None if invalid

        Examples:
            >>> extract_ip("192.168.1.1")
            "192.168.1.1"
            >>> extract_ip("http://192.168.1.1")
            "192.168.1.1"
            >>> extract_ip("https://192.168.1.1:8080")
            "192.168.1.1"
        """
        parsed_url = NetworkUtils.normalize_ip_url(url)
        if not parsed_url:
            return None

        try:
            f = furl(parsed_url)
            ip = f.host
            # Validate it's a valid IP
            ipaddress.ip_address(ip)
            return ip
        except ValueError:
            return None

    @staticmethod
    def normalize_ip_url(url: str) -> Optional[str]:
        """
        Normalize and validate a URL or IP address into a consistent URL format.
        Returns normalized URL if valid IP-based URL, None if invalid.

        Args:
            url (str): URL or IP address

        Returns:
            Optional[str]: Normalized URL or None if invalid

        Examples:
            >>> normalize_ip_url("192.168.1.1")
            "http://192.168.1.1"
            >>> normalize_ip_url("http://192.168.1.1")
            "http://192.168.1.1"
            >>> normalize_ip_url("envoy.local")
            None
            >>> normalize_ip_url("http://google.com")
            None  # Not an IP-based URL
        """
        try:
            # If it's just an IP, convert it to a URL
            try:
                ipaddress.ip_address(url)
                f = furl(scheme='http', host=url)
            except ValueError:
                f = furl(url)

            # Validate the host is an IP address
            if not f.host:
                return None

            ipaddress.ip_address(f.host)
            return str(f)

        except ValueError:
            return None

    @staticmethod
    def arp_table() -> list[dict[str, str]]:
        """Refresh the ARP table from the system."""
        try:
            with open('/proc/net/arp', 'r', encoding='utf-8') as f:
                lines = f.readlines()[1:]  # Skip the header line

            arp_table = [
                dict(zip([NetworkUtils.IP_KEY,
                          NetworkUtils.HW_KEY,
                          NetworkUtils.FLAGS_KEY,
                          NetworkUtils.MAC_KEY,
                          NetworkUtils.MASK_KEY,
                          NetworkUtils.DEVICE_KEY], line.split()))
                for line in lines
            ]
            return arp_table
        except FileNotFoundError:
            logger.warning("ARP table file not found. Using empty ARP table.")
            return []

    @staticmethod
    def get_mac_from_ip(ip: str) -> str:
        """Get the MAC address from the ARP table for a given IP address or URL."""
        ip = NetworkUtils.extract_ip(ip)
        for entry in NetworkUtils.arp_table():
            if entry[NetworkUtils.IP_KEY] == ip:
                return entry[NetworkUtils.MAC_KEY]
        return NetworkUtils.INVALID_MAC

    @staticmethod
    def parse_ports(ports_str: str) -> list[int]:
        """Parse a string of ports and port ranges into a list of integers."""
        ports = []
        for part in ports_str.split(','):
            if '-' in part:
                start, end = map(int, part.split('-'))
                ports.extend(range(start, end + 1))
            else:
                ports.append(int(part))
        return ports

    @staticmethod
    def is_port_open(ip: str, port: int, timeout: float) -> bool:
        """Check if a specific port is open on a given IP address."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(float(timeout))

            sock.connect((ip, port))
            sock.close()
            return True
        except (socket.error, ValueError):
            return False

    @staticmethod
    def _check_host(ip_port: Tuple[str, int], timeout: float) -> Optional[HostInfo]:
        """Helper method to check a single IP:port combination"""
        ip_str, port = ip_port
        if NetworkUtils.is_port_open(ip_str, port, timeout):
            return HostInfo(
                ip=ip_str,
                port=port,
                mac=NetworkUtils.get_mac_from_ip(ip_str)
            )
        return None

    @staticmethod
    def get_hosts(ports: list[int], timeout: float) -> list[HostInfo]:
        """
        Scan the local network for modbus devices on the given ports using parallel threading.
        """
        try:
            timeout = float(timeout)
        except (TypeError, ValueError):
            logger.warning("Invalid timeout value, using default: %s", NetworkUtils.DEFAULT_TIMEOUT)
            timeout = NetworkUtils.DEFAULT_TIMEOUT

        try:
            # Get local IP using socket
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            local_ip = s.getsockname()[0]
            s.close()
        except Exception as e:
            logger.error("Failed to get IP address: %s", str(e))
            return []

        if not local_ip:
            logger.warning("No active network connection found.")
            return []

        # Refresh the ARP table
        NetworkUtils.arp_table()

        # Extract the network prefix from the local IP address
        network_prefix = ".".join(local_ip.split(".")[:-1]) + ".0/24"
        subnet = ipaddress.ip_network(network_prefix)

        logger.info("Scanning subnet %s for modbus devices on ports %s with timeout %s", subnet, ports, timeout)

        # Create list of all IP:port combinations to check
        ip_port_combinations = [(str(ip), port) for ip in subnet.hosts() for port in ports]
        logger.info("Checking %s IP:port combinations", len(ip_port_combinations))

        # Use ThreadPoolExecutor for parallel scanning
        with ThreadPoolExecutor(max_workers=255) as executor:
            results = executor.map(
                lambda x: NetworkUtils._check_host(x, timeout),
                ip_port_combinations
            )

        # Filter out None results and convert to list
        hosts = [result for result in results if result is not None]

        if not hosts:
            logger.info("No IPs with given port(s) %s open found in the subnet %s", ports, subnet)
            return []

        logger.info("Found %s hosts: %s", len(hosts), hosts)

        return hosts

    @classmethod
    def start_mdns_advertisement(cls, port: int = 80, properties: Dict[str, Any] = None) -> bool:
        """Start mDNS advertisement for the gateway.

        Args:
            port: Port to advertise
            properties: Additional properties to include in the advertisement

        Returns:
            bool: True if mDNS advertisement was started successfully, False otherwise
        """
        properties = properties or {}
        hostname = cls.MDNS_HOSTNAME

        try:
            # Close existing advertiser if present
            if cls._mdns_advertiser is not None:
                logger.info("Stopping existing mDNS advertisement")
                cls._mdns_advertiser.unregister()

            # Create new advertiser and register
            cls._mdns_advertiser = MDNSAdvertiser()

            try:
                cls._mdns_advertiser.register_gateway(
                    hostname=hostname,
                    port=port,
                    properties=properties
                )
                logger.info(f"mDNS advertisement started for {hostname}.local")
                return True
            except Exception as e:

                from zeroconf._exceptions import NonUniqueNameException

                if isinstance(e, NonUniqueNameException):
                    # Create fallback hostname with serial number or timestamp
                    serial_number = properties.get(CryptoState.serial_no_key(), '')
                    if not serial_number:
                        # Fallback to timestamp if no serial number
                        logger.info("No serial number found, falling back to timestamp")
                        import time
                        serial_number = str(int(time.time()))

                    # Use last 6 chars for better readability and store the 6 in a variable
                    serial_suffix_length = 6
                    serial_suffix = serial_number[-serial_suffix_length:] if len(serial_number) >= serial_suffix_length else serial_number
                    unique_hostname = f"{hostname}-{serial_suffix}"

                    logger.warning(f"Name conflict for {hostname}.local, trying {unique_hostname}.local")

                    # Try with unique hostname
                    cls._mdns_advertiser.register_gateway(
                        hostname=unique_hostname,
                        port=port,
                        properties=properties
                    )
                    logger.info(f"mDNS advertisement started as: {unique_hostname}.local")
                    return True

                # Re-raise for outer exception handler
                raise
        except Exception as e:
            # More detailed error logging
            import traceback
            from zeroconf._exceptions import NonUniqueNameException

            if isinstance(e, NonUniqueNameException):
                logger.error(f"Failed to start mDNS advertisement: Another device is already using the name '{hostname}.local' on your network")
                logger.info("The service will be registered with a numeric suffix automatically")
            else:
                error_details = traceback.format_exc()
                logger.error(f"Failed to start mDNS advertisement: {str(e)}")
                logger.debug(f"Exception details: {error_details}")
            return False

    @classmethod
    def stop_mdns_advertisement(cls) -> bool:
        """Stop mDNS advertisement.

        Returns:
            bool: True if mDNS advertisement was stopped successfully, False otherwise
        """
        logger = logging.getLogger(__name__)

        if cls._mdns_advertiser is not None:
            try:
                cls._mdns_advertiser.unregister()
                cls._mdns_advertiser = None
                logger.info("mDNS advertisement stopped")
                return True
            except Exception as e:
                logger.error(f"Failed to stop mDNS advertisement: {e}")
        return False

    @classmethod
    def start_mdns_after_dns_resolution(cls, port: int = 80, properties: Dict[str, Any] = None,
                                        max_attempts: int = 5, wait_seconds: int = 1) -> bool:
        """Start mDNS advertisement after DNS servers are properly resolved.

        This method checks for DNS resolution and starts mDNS advertisement
        when DNS servers are available.

        Args:
            port: The port to advertise the service on
            properties: Additional properties to include in the advertisement
            max_attempts: Maximum number of attempts to check for DNS
            wait_seconds: Time to wait between attempts

        Returns:
            bool: True if mDNS advertisement was started successfully, False otherwise
        """
        import time
        logger = logging.getLogger(__name__)

        for attempt in range(max_attempts):
            logger.info(f"Attempt {attempt+1}/{max_attempts} to start mDNS advertisement")
            res = cls.start_mdns_advertisement(port, properties)
            if res:
                return True
            time.sleep(wait_seconds)
        return False

    @classmethod
    def discover_blixt_devices(cls, scan_duration: int = 5) -> List[Dict[str, str]]:
        """Discover blixt devices on the local network using mDNS.

        Scans the network for devices that advertise themselves with the blixt hostname
        via mDNS and returns their hostnames and IP addresses.

        Args:
            scan_duration: Duration in seconds to scan for devices

        Returns:
            List of dictionaries containing 'hostname' and 'ip' for each discovered blixt device
        """
        from server.network.mdns.mdns import scan

        logger = logging.getLogger(__name__)
        logger.info(f"Scanning for blixt devices on the network for {scan_duration} seconds...")

        # Get current device's IP to exclude it from results
        current_ip = cls.get_ip_address()

        # Scan for sourceful services
        service_type = "_sourceful._tcp.local."
        results = scan(duration=scan_duration, services=service_type)

        devices = []
        for result in results:
            if result.address and result.address != current_ip:  # Skip the current device
                hostname = result.name.split('.')[0]  # Extract hostname from the full service name
                devices.append({
                    'hostname': hostname,
                    'ip': result.address
                })
                logger.info(f"Found blixt device: {hostname} at {result.address}")

        return devices

    # WiFi stuff
    @staticmethod
    def get_wifi_ssids() -> list[str]:
        """Get the list of available WiFi SSIDs."""
        return [ap for ap in WiFiManager.scan_networks()]

    @staticmethod
    def connect_to_wifi(ssid: str, psk: str, timeout: int) -> bool:
        """Connect to a WiFi network.

        Args:
            ssid: The SSID of the WiFi network
            psk: The password of the WiFi network
            timeout: The timeout in seconds to wait for the connection
        """
        return WiFiManager.connect(ssid, psk, timeout)

    @staticmethod
    def disconnect_from_wifi() -> bool:
        """Disconnect from a WiFi network."""
        return WiFiManager.disconnect()

    @staticmethod
    def get_connected_wifi_ssid() -> str:
        """Get the SSID of the connected WiFi network."""
        return WiFiManager.get_wifi_ssid()

    @staticmethod
    def get_network_interfaces() -> dict:
        return WiFiManager.get_network_interfaces()

    @staticmethod
    def get_network_devices() -> dict:
        return WiFiManager.get_network_devices()

    @staticmethod
    def get_eth0_mac() -> str:
        return WiFiManager.get_mac_address('eth0')

    @staticmethod
    def get_wlan0_mac() -> str:
        return WiFiManager.get_mac_address('wlan0')
