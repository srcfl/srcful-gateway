from dataclasses import dataclass, asdict
import logging
from typing import Optional, Tuple, List, Dict, Any
import socket
import ipaddress
import subprocess
from furl import furl
from concurrent.futures import ThreadPoolExecutor
from server.network.mdns import MDNSAdvertiser


try:
    import dbus
except Exception:
    pass

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

try:
    import dbus
except ImportError:
    logger.info("dbus not found - possibly on non linux platform")
    logger.info("wifi provisioning will not work")


@dataclass
class HostInfo:
    ip: str
    port: int
    mac: str

    def __iter__(self):
        yield from asdict(self).items()

    def to_dict(self):
        return asdict(self)


class NetworkUtils:
    """
    Utility class for network-related operations.
    """

    IP_KEY = 'ip'
    PORT_KEY = 'port'
    PORTS_KEY = 'ports'
    MAC_KEY = 'mac'
    HW_KEY = 'hw'
    FLAGS_KEY = 'flags'
    MASK_KEY = 'mask'
    DEVICE_KEY = 'device'
    TIMEOUT_KEY = 'timeout'
    DEFAULT_MODBUS_PORTS = "502,6607,8899"
    DEFAULT_TIMEOUT = 5

    INVALID_MAC = "00:00:00:00:00:00"
    SOURCEFUL_HOSTNAME = "blixt"

    _mdns_advertiser = None

    def __init__(self):
        raise NotImplementedError("This class shouldn't be instantiated.")

    @staticmethod
    def get_ip_address() -> str:
        """Get the IP address of the device."""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip_address = s.getsockname()[0]
            s.close()
            return ip_address
        except Exception:
            return "0.0.0.0"

    @staticmethod
    def get_dns_servers() -> List[str]:
        """Get DNS servers from NetworkManager via D-Bus."""
        try:
            bus = dbus.SystemBus()
            nm = bus.get_object('org.freedesktop.NetworkManager', '/org/freedesktop/NetworkManager')

            # Get all devices
            try:
                devices = nm.GetDevices(dbus_interface='org.freedesktop.NetworkManager')
            except dbus.exceptions.DBusException as e:
                logger.warning("Failed to get network devices: %s", str(e))
                return []

            for d in devices:
                try:
                    device = bus.get_object('org.freedesktop.NetworkManager', d)
                    device_props = dbus.Interface(device, 'org.freedesktop.DBus.Properties')

                    # Check if device is active
                    state = device_props.Get('org.freedesktop.NetworkManager.Device', 'State')
                    if state != 100:  # 100 = activated
                        continue

                    # Get IP4Config
                    ip4_config_path = device_props.Get('org.freedesktop.NetworkManager.Device', 'Ip4Config')
                    if ip4_config_path == '/':
                        continue

                    ip4_config = bus.get_object('org.freedesktop.NetworkManager', ip4_config_path)
                    ip4_props = dbus.Interface(ip4_config, 'org.freedesktop.DBus.Properties')

                    # Get nameservers
                    nameservers = ip4_props.Get('org.freedesktop.NetworkManager.IP4Config', 'NameserverData')
                    if nameservers:
                        dns_servers = [ns['address'] for ns in nameservers]
                        logger.info("Found DNS servers: %s", dns_servers)
                        return dns_servers
                except dbus.exceptions.DBusException as e:
                    logger.warning("Failed to get DNS info from device %s: %s", d, str(e))
                    continue

            return []
        except Exception as e:
            logger.warning("Failed to get DNS servers from NetworkManager: %s", str(e))
            return []

    @staticmethod
    def update_resolv_conf(dns_servers: List[str]) -> bool:
        """Update resolv.conf with DNS servers."""
        if not dns_servers:
            return False

        try:
            content = "# Generated by NetworkManager\n"
            content += "search localdomain\n"
            for server in dns_servers:
                content += f"nameserver {server}\n"

            with open('/etc/resolv.conf', 'w') as f:
                f.write(content)
            logger.info("Updated resolv.conf with DNS servers")
            return True
        except Exception as e:
            logger.warning("Failed to update resolv.conf: %s", str(e))
            return False

    @staticmethod
    def verify_network_connectivity() -> bool:
        """Verify network connectivity by checking DNS resolution."""
        try:
            # Get and set DNS configuration from NetworkManager
            dns_servers = NetworkUtils.get_dns_servers()
            if dns_servers:
                NetworkUtils.update_resolv_conf(dns_servers)
            else:
                logger.warning("No DNS servers found from NetworkManager")

            # Try DNS resolution
            logger.debug("Testing network connectivity...")
            # Try to ping Google's IP to test connectivity
            result = subprocess.run(
                ["ping", "-c", "5", "74.125.200.139"],
                check=False,
                capture_output=True,
                text=True,
                timeout=10
            )

            # Print the ping results to console for debugging
            print("\n=== PING TEST RESULTS ===")
            print(result.stdout)
            print("=== END PING TEST ===\n")

            if result.returncode == 0:
                logger.debug("Network connectivity test successful")
                return True
            else:
                logger.warning("Network connectivity test failed")
                return False

        except Exception as e:
            logger.warning("Network connectivity check failed: %s", str(e))
            return False

    @staticmethod
    def extract_ip(url: str) -> Optional[str]:
        """
        Extract IP address from a URL or IP string.
        Returns the IP if valid, None if invalid.

        Args:
            url (str): URL or IP address string

        Returns:
            Optional[str]: IP address or None if invalid

        Examples:
            >>> extract_ip("192.168.1.1")
            "192.168.1.1"
            >>> extract_ip("http://192.168.1.1")
            "192.168.1.1"
            >>> extract_ip("https://192.168.1.1:8080")
            "192.168.1.1"
        """
        parsed_url = NetworkUtils.normalize_ip_url(url)
        if not parsed_url:
            return None

        try:
            f = furl(parsed_url)
            ip = f.host
            # Validate it's a valid IP
            ipaddress.ip_address(ip)
            return ip
        except ValueError:
            return None

    @staticmethod
    def normalize_ip_url(url: str) -> Optional[str]:
        """
        Normalize and validate a URL or IP address into a consistent URL format.
        Returns normalized URL if valid IP-based URL, None if invalid.

        Args:
            url (str): URL or IP address

        Returns:
            Optional[str]: Normalized URL or None if invalid

        Examples:
            >>> normalize_ip_url("192.168.1.1")
            "http://192.168.1.1"
            >>> normalize_ip_url("http://192.168.1.1")
            "http://192.168.1.1"
            >>> normalize_ip_url("envoy.local")
            None
            >>> normalize_ip_url("http://google.com")
            None  # Not an IP-based URL
        """
        try:
            # If it's just an IP, convert it to a URL
            try:
                ipaddress.ip_address(url)
                f = furl(scheme='http', host=url)
            except ValueError:
                f = furl(url)

            # Validate the host is an IP address
            if not f.host:
                return None

            ipaddress.ip_address(f.host)
            return str(f)

        except ValueError:
            return None

    # Method to get the arp table
    @staticmethod
    def arp_table() -> list[dict[str, str]]:
        """Refresh the ARP table from the system."""
        logger.debug("Scanning ARP table")
        try:
            with open('/proc/net/arp', 'r', encoding='utf-8') as f:
                lines = f.readlines()[1:]  # Skip the header line

            arp_table = [
                dict(zip([NetworkUtils.IP_KEY,
                          NetworkUtils.HW_KEY,
                          NetworkUtils.FLAGS_KEY,
                          NetworkUtils.MAC_KEY,
                          NetworkUtils.MASK_KEY,
                          NetworkUtils.DEVICE_KEY], line.split()))
                for line in lines
            ]
            return arp_table
        except FileNotFoundError:
            logger.warning("ARP table file not found. Using empty ARP table.")
            return []

    @staticmethod
    def get_mac_from_ip(ip: str) -> str:
        """Get the MAC address from the ARP table for a given IP address or URL."""
        ip = NetworkUtils.extract_ip(ip)
        for entry in NetworkUtils.arp_table():
            if entry[NetworkUtils.IP_KEY] == ip:
                return entry[NetworkUtils.MAC_KEY]
        return NetworkUtils.INVALID_MAC

    @staticmethod
    def parse_ports(ports_str: str) -> list[int]:
        """Parse a string of ports and port ranges into a list of integers."""
        ports = []
        for part in ports_str.split(','):
            if '-' in part:
                start, end = map(int, part.split('-'))
                ports.extend(range(start, end + 1))
            else:
                ports.append(int(part))
        return ports

    @staticmethod
    def is_port_open(ip: str, port: int, timeout: float) -> bool:
        """Check if a specific port is open on a given IP address."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(float(timeout))

            sock.connect((ip, port))
            sock.close()
            return True
        except (socket.error, ValueError):
            return False

    @staticmethod
    def _check_host(ip_port: Tuple[str, int], timeout: float) -> Optional[HostInfo]:
        """Helper method to check a single IP:port combination"""
        ip_str, port = ip_port
        if NetworkUtils.is_port_open(ip_str, port, timeout):
            return HostInfo(
                ip=ip_str,
                port=port,
                mac=NetworkUtils.get_mac_from_ip(ip_str)
            )
        return None

    @staticmethod
    def get_hosts(ports: list[int], timeout: float) -> list[HostInfo]:
        """
        Scan the local network for modbus devices on the given ports using parallel threading.
        """
        try:
            timeout = float(timeout)
        except (TypeError, ValueError):
            logger.warning("Invalid timeout value, using default: %s", NetworkUtils.DEFAULT_TIMEOUT)
            timeout = NetworkUtils.DEFAULT_TIMEOUT

        try:
            # Get local IP using socket
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            local_ip = s.getsockname()[0]
            s.close()
        except Exception as e:
            logger.error("Failed to get IP address: %s", str(e))
            return []

        if not local_ip:
            logger.warning("No active network connection found.")
            return []

        # Refresh the ARP table
        NetworkUtils.arp_table()

        # Extract the network prefix from the local IP address
        network_prefix = ".".join(local_ip.split(".")[:-1]) + ".0/24"
        subnet = ipaddress.ip_network(network_prefix)

        logger.info("Scanning subnet %s for modbus devices on ports %s with timeout %s", subnet, ports, timeout)

        # Create list of all IP:port combinations to check
        ip_port_combinations = [(str(ip), port) for ip in subnet.hosts() for port in ports]
        logger.info("Checking %s IP:port combinations", len(ip_port_combinations))

        # Use ThreadPoolExecutor for parallel scanning
        with ThreadPoolExecutor(max_workers=255) as executor:
            results = executor.map(
                lambda x: NetworkUtils._check_host(x, timeout),
                ip_port_combinations
            )

        # Filter out None results and convert to list
        hosts = [result for result in results if result is not None]

        if not hosts:
            logger.info("No IPs with given port(s) %s open found in the subnet %s", ports, subnet)
            return []

        logger.info("Found %s hosts: %s", len(hosts), hosts)

        return hosts

    @classmethod
    def start_mdns_advertisement(cls, port: int = 80, properties: Dict[str, Any] = None) -> bool:
        """Start mDNS advertisement after DNS is resolved.

        Args:
            port: The port to advertise the service on
            properties: Additional properties to include in the advertisement

        Returns:
            bool: True if mDNS advertisement was started successfully, False otherwise
        """
        logger = logging.getLogger(__name__)

        # Initialize properties if None
        if properties is None:
            properties = {}

        try:
            # Close existing advertiser if present
            if cls._mdns_advertiser is not None:
                cls._mdns_advertiser.unregister()

            # Create new advertiser
            cls._mdns_advertiser = MDNSAdvertiser()
            cls._mdns_advertiser.register_gateway(
                hostname=cls.SOURCEFUL_HOSTNAME,
                port=port,
                properties=properties
            )
            logger.info(f"mDNS advertisement started for {cls.SOURCEFUL_HOSTNAME}.local")
            return True
        except Exception as e:
            logger.error(f"Failed to start mDNS advertisement: {e}")
            return False

    @classmethod
    def stop_mdns_advertisement(cls) -> bool:
        """Stop mDNS advertisement.

        Returns:
            bool: True if mDNS advertisement was stopped successfully, False otherwise
        """
        logger = logging.getLogger(__name__)

        if cls._mdns_advertiser is not None:
            try:
                cls._mdns_advertiser.unregister()
                cls._mdns_advertiser = None
                logger.info("mDNS advertisement stopped")
                return True
            except Exception as e:
                logger.error(f"Failed to stop mDNS advertisement: {e}")

        return False

    @classmethod
    def start_mdns_after_dns_resolution(cls, port: int = 80, properties: Dict[str, Any] = None,
                                        max_attempts: int = 10, wait_seconds: int = 1) -> bool:
        """Start mDNS advertisement after DNS servers are properly resolved.

        This method checks for DNS resolution and starts mDNS advertisement
        when DNS servers are available.

        Args:
            port: The port to advertise the service on
            properties: Additional properties to include in the advertisement
            max_attempts: Maximum number of attempts to check for DNS
            wait_seconds: Time to wait between attempts

        Returns:
            bool: True if mDNS advertisement was started successfully, False otherwise
        """
        import time
        logger = logging.getLogger(__name__)

        attempt = 0
        while attempt < max_attempts:
            dns_servers = cls.get_dns_servers()
            if dns_servers:
                logger.info(f"DNS servers resolved: {dns_servers}, starting mDNS advertisement")
                return cls.start_mdns_advertisement(port, properties)

            logger.debug(f"DNS servers not yet resolved (attempt {attempt+1}/{max_attempts}), waiting...")
            time.sleep(wait_seconds)
            attempt += 1

        logger.warning(f"Failed to resolve DNS servers after {max_attempts} attempts")
        # Try to start mDNS anyway as a fallback
        return cls.start_mdns_advertisement(port, properties)
